<?php

namespace Cube\Console\Commands\DataToObject\Classes;

use Cube\Data\Bunch;
use Cube\Data\Classes\ArrayOf;
use Cube\Data\Classes\BunchOf;
use Cube\Data\DataToObject;
use Cube\Env\Storage;
use Cube\Utils\Path;
use Cube\Utils\Text;
use Cube\Utils\Utils;

class DataToObjectGenClass
{
    /** @var array<string,DataToObjectGenClass|string> */
    protected array $properties = [];

    public function __construct(
        public string $className,
        public array $sampleData,
        public bool $isArray = false
    )
    {
        $this->parseSampleData($sampleData);
    }

    public function attributeName(string $key)
    {
        return preg_replace_callback('/(\w)[\-_](\w)/', function($match) {
            return $match[1] . strtoupper($match[2]);
        }, $key);
    }

    public function className(string $key)
    {
        return ucfirst($this->attributeName($key));
    }

    public function parseSampleValue(string $key, mixed $value)
    {
        if (is_array($value))
        {
            if (!count($value))
                return "array";

            $isList = Utils::isList($value);
            $sample = $isList ? $value[0]: $value;

            if (!is_array($sample))
                return $this->parseSampleValue($key, $sample);

            return new self($key, $sample, $isList);
        }

        switch (gettype($value))
        {
            case 'boolean':
                return "bool";
            case 'integer':
                return "int";
            case 'double':
                return "float";
        }

        if (preg_match('/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/', $value))
            return '\Datetime';

        return "string";
    }

    public function parseSampleData(array $data)
    {
        foreach ($data as $key => $value)
        {
            $this->properties[$key] = $this->parseSampleValue($key, $value);
        }
    }

    protected function generateFields(): string
    {
        return Bunch::unzip($this->properties)
            ->map(function($pair) {

                list($name, $type) = $pair;
                $name = $this->attributeName($name);


                if (! $type instanceof self)
                    return "\t\t\t\tpublic $type \$$name";

                if ($type->isArray)
                {
                    return
                        "\t\t\t\t#[ArrayOf(".$type->className($type->className)."::class)]\n".
                        "\t\t\t\tpublic array \$$name";
                }

                return "\t\t\t\tpublic " . $type->className($type->className) . " \$$name";

            })
            ->join(",\n");
    }

    public function generateInto(Storage $directory)
    {
        $namespace = Path::pathToNamespace($directory);
        $className = $this->className($this->className);

        $uses = Bunch::fromValues($this->properties)
            ->onlyInstancesOf(self::class)
            ->map(fn(self $x) => $this->className($x->className))
            ->map(fn($x) => "use $namespace\\$x\\$x;")
            ->join("\n");

        $phpDoc = Bunch::unzip($this->properties)
            ->filter(fn($pair) => $pair[1] instanceof self)
            ->filter(fn($pair) => $pair[1]->isArray)
            ->map(fn($pair) => " * @property " . $this->className($pair[1]->className). "[] $". $this->attributeName($pair[0]))
            ->join("\n");

        $fields = $this->generateFields();

        $directory->write($className . ".php", Text::toFile(
        "<?php

        namespace $namespace;

        use ". DataToObject::class .";
        use ". ArrayOf::class .";
        use ". BunchOf::class .";
        $uses

        /**
         * Generated by ".self::class." on ". date("Y-m-d H:i:s") ."
        $phpDoc
        */
        class $className extends DataToObject
        {
            public function __construct(\n$fields
            ) {}
        }
        "));

        Bunch::fromValues($this->properties)
            ->onlyInstancesOf(self::class)
            ->forEach(function($type) use ($directory) {
                $classname = $type->className($type->className);
                $type->generateInto($directory->child($classname));
            });
    }
}